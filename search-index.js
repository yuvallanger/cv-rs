var N = null;var searchIndex = {};
searchIndex["cv"]={"doc":"This library primarily provides a binding and API for OpenCV 3.x.","items":[[0,"core","cv","Core data structures in OpenCV",N,N],[3,"KeyPoint","cv::core","Data structure for salient point detectors",N,N],[12,"point","","Coordinates of the keypoint",0,N],[12,"size","","Diameter of the meaningful keypoint neighborhood",0,N],[12,"angle","","Computed orientation of the keypoint (-1 if not applicable); it's in [0,360) degrees and measured relative to image coordinate system, ie in clockwise.",0,N],[12,"response","","The response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling",0,N],[12,"octave","","Octave (pyramid layer) from which the keypoint has been extracted",0,N],[12,"class_id","","Object class (if the keypoints need to be clustered by an object they belong to)",0,N],[3,"Scalar","","A 4-element struct that is widely used to pass pixel values.",N,N],[3,"Point2i","","2D integer points specified by its coordinates `x` and `y`.",N,N],[12,"x","","x coordinate",1,N],[12,"y","","y coordinate",1,N],[3,"Point2f","","2D floating points specified by its coordinates `x` and `y`.",N,N],[12,"x","","x coordinate",2,N],[12,"y","","y coordinate",2,N],[3,"Size2i","","`Size2i` struct is used for specifying the size of an image or rectangle with integer dimensions.",N,N],[12,"width","","width",3,N],[12,"height","","height",3,N],[3,"Size2f","","`Size2f` struct is used for specifying the size of an image or rectangle with float dimensions.",N,N],[12,"width","","width",4,N],[12,"height","","height",4,N],[3,"Rect","","The `Rect` defines a rectangle in integer.",N,N],[12,"x","","x coordinate of the left-top corner",5,N],[12,"y","","y coordinate of the left-top corner",5,N],[12,"width","","width of this rectangle",5,N],[12,"height","","height of this rectangle",5,N],[3,"Rect2f","","The `Rect2f` are rectangles in float.",N,N],[12,"x","","x coordinate of the left-top corner",6,N],[12,"y","","y coordinate of the left-top corner",6,N],[12,"width","","width of this rectangle",6,N],[12,"height","","height of this rectangle",6,N],[3,"RotatedRect","","This struct represents a rotated (i.e. not up-right) rectangle. Each rectangle is specified by the center point (mass center), length of each side (represented by `Size2f`) and the rotation angle in degrees.",N,N],[3,"TermCriteria","","Termination criteria for iterative algorithms.",N,N],[4,"LineType","","Line type",N,N],[13,"Filled","","Default type",7,N],[13,"Line4","","4-connected line",7,N],[13,"Line8","","8-connected line",7,N],[13,"LineAA","","antialiased line",7,N],[4,"FlipCode","","A flag to specify how to flip the image. see Mat::flip",N,N],[13,"XAxis","","Along x-axis: dst[i, j] = src[src.rows - i - 1, j]",8,N],[13,"YAxis","","Along y-axis: dst[i, j] = src[i, src.cols - j - 1]",8,N],[13,"XYAxis","","Along both axis: dst[i, j] = src[src.rows - i - 1, src.cols - j - 1]",8,N],[4,"CvType","","Here is the `CvType` in an easy-to-read table.",N,N],[13,"Cv8UC1","","8 bit unsigned, single channel (grey image)",9,N],[13,"Cv8SC1","","8 bit signed, single channel (grey image)",9,N],[13,"Cv16UC1","","16 bit unsigned, single channel (grey image)",9,N],[13,"Cv16SC1","","16 bit signed, single channel (grey image)",9,N],[13,"Cv32SC1","","32 bit signed, single channel (grey image)",9,N],[13,"Cv32FC1","","32 bit float, single channel (grey image)",9,N],[13,"Cv64FC1","","32 bit float, single channel (grey image)",9,N],[13,"Cv8UC2","","8 bit, two channel (rarelly seen)",9,N],[13,"Cv8UC3","","8 bit unsigned, three channels (RGB image)",9,N],[13,"Cv8SC3","","8 bit signed, three channels (RGB image)",9,N],[13,"Cv16UC3","","16 bit unsigned, three channels (RGB image)",9,N],[13,"Cv16SC3","","16 bit signed, three channels (RGB image)",9,N],[13,"Cv32SC3","","32 bit signed, three channels (RGB image)",9,N],[13,"Cv32FC3","","32 bit float, three channels (RGB image)",9,N],[13,"Cv64FC3","","32 bit float, three channels (RGB image)",9,N],[4,"NormType","","Normalization type. Please refer to OpenCV's documentation.",N,N],[13,"Inf","","Normalized using `max`",10,N],[13,"L1","","Normalized using L1 distance",10,N],[13,"L2","","Normalized using L2 distance",10,N],[13,"L2Sqr","","Normalized using L2 sqr distance",10,N],[13,"Hamming","","Normalized using hamming distance",10,N],[13,"Hamming2","","Normalized using hamming2 distance",10,N],[13,"Relative","","Normalized using relative distance",10,N],[13,"MinMax","","Normalized using minmax distance",10,N],[4,"TermType","","Term criteria type, can be one of: Count, Eps or Count + Eps",N,N],[13,"Count","","The maximum number of iterations or elements to compute",11,N],[13,"EPS","","the desired accuracy or change in parameters at which the iterative algorithm stops.",11,N],[8,"FromBytes","","Allow self deserialization from byte slice",N,N],[10,"from_bytes","","Deserializes self from byte slice",12,N],[11,"new","","Creates a new scalar object.",13,[[["c_int"],["c_int"],["c_int"],["c_int"]],["self"]]],[11,"all","","Creates a new scalar object with all value being the same.",13,[[["c_int"]],["self"]]],[11,"new","","Creats a new `Point2i`.",1,[[["c_int"],["c_int"]],["self"]]],[11,"new","","Creats a new `Point2f`.",2,[[["f32"],["f32"]],["self"]]],[11,"new","","Creates a new `Size2i` object with `width` and `height`",3,[[["c_int"],["c_int"]],["self"]]],[11,"new","","Creates a new `Rect` with (x, y, width, height) parameters.",5,[[["c_int"],["c_int"],["c_int"],["c_int"]],["self"]]],[11,"scale","","Scales the rectangle by the specified ratio.",5,[[["self"],["f32"]],["rect"]]],[11,"normalize_to_mat","","Normalize the rectangle according to the image (if the rectangle is inside the image, then the result should be all within (0, 1).",5,[[["self"],["mat"]],["rect2f"]]],[11,"normalize_to_mat","","Normalize the rectangle according to the image. This will restore the Rect in absolute pixel numbers.",6,[[["self"],["mat"]],["rect"]]],[11,"points","","Return 4 vertices of the rectangle.",14,N],[11,"bounding_rect","","Return the minimal up-right rectangle containing the rotated rectangle",14,[[["self"]],["rect"]]],[11,"new","","Creates a new termination criteria.",15,[[["termtype"],["c_int"],["f64"]],["self"]]],[0,"cuda","cv","Bindings to OpenCV's classes and functions that exploits GPU/Cuda. See cv::cuda",N,N],[3,"GpuMat","cv::cuda","`GpuMat` data structure in rust, bound to an opaque type in C/C++.",N,N],[12,"cols","","Number of columns",16,N],[12,"rows","","Number of rows",16,N],[12,"depth","","Depth of this mat",16,N],[3,"GpuHog","","Data structure that performs Histogram of Gradient (HOG).",N,N],[12,"params","","Hog parameters.",17,N],[12,"return_score","","Should return detection scores",17,N],[3,"GpuCascade","","Data structure that performs object detection with a cascade classifier.",N,N],[4,"CGpuMat","","Opaque data struct for C/C++ cv::cuda::GpuMat bindings",N,N],[4,"CGpuHog","","Opaque data struct for C bindings",N,N],[4,"CGpuCascade","","Opaque data struct for C bindings",N,N],[11,"default","","Creates a default `GpuMat`.",16,[[],["gpumat"]]],[11,"upload","","Uploads a normal `Mat`",16,[[["self"],["mat"]]]],[11,"new","","Creates a new GpuHog detector.",17,[[["size2i"],["size2i"],["size2i"],["size2i"],["c_int"]],["gpuhog"]]],[11,"return_score","","Should or not return the detection score",17,[[["self"],["bool"]]]],[11,"with_params","","Creates a new GpuHog detector with parameters specified inside `params`.",17,[[["hogparams"]],["gpuhog"]]],[11,"set_svm_detector","","Sets the SVM detector.",17,[[["self"],["svmdetector"]]]],[11,"from_path","","Loads the classifier from a file.",18,[[["p"]],["result",["error"]]]],[11,"detect_multiscale","","Detects objects of different sizes in the input image.",18,[[["self"],["gpumat"]],["vec",["rect"]]]],[11,"set_find_largest_object","","Sets whether or not to find the only largest object.",18,[[["self"],["bool"]]]],[11,"set_max_num_objects","","Sets the maximum number of objects.",18,[[["self"],["c_int"]]]],[11,"set_min_neighbors","","Sets minimal neighbors required for a detection to be valid.",18,[[["self"],["c_int"]]]],[11,"set_max_object_size","","Sets the maximun object size.",18,[[["self"],["size2i"]]]],[11,"set_min_object_size","","Sets the minimal object size.",18,[[["self"],["size2i"]]]],[11,"set_scale_factor","","Sets the scale factor used in multiscale detection.",18,[[["self"],["f64"]]]],[11,"get_classifier_size","","Returns the classifier size.",18,[[["self"]],["size2i"]]],[11,"get_find_largest_object_flag","","Returns if the CascadeClassifier will only return the largest object.",18,[[["self"]],["bool"]]],[11,"get_max_num_objects","","Returns the allowed maximal number of detected objects.",18,[[["self"]],["c_int"]]],[11,"get_min_neighbors","","Returns the number of minimal neighbors required for a detection to be valid.",18,[[["self"]],["c_int"]]],[11,"get_max_object_size","","Returns the maximum object size.",18,[[["self"]],["size2i"]]],[11,"get_min_object_size","","Returns the minimal object size.",18,[[["self"]],["size2i"]]],[11,"get_scale_factor","","Returns the scale factor.",18,[[["self"]],["f64"]]],[0,"errors","cv","Errors for OpenCV bindings",N,N],[4,"CvError","cv::errors","Custom errors that may happen during calls",N,N],[13,"InvalidPath","","Indicates that path was invalid",19,N],[13,"EntryNotFound","","Indicates that there is no entry on specified path",19,N],[13,"UnknownError","","Indicates that error occurred in C++ code",19,N],[13,"UnicodeChars","","Indicates that string contains non ascii characters",19,N],[0,"features2d","cv","Provide 2D image feature detectors and descriptor extractors",N,N],[3,"BOWKMeansTrainer","cv::features2d","K-means - based class to train visual vocabulary using the bag of visual words approach",N,N],[3,"DMatch","","Type for matching keypoint descriptors",N,N],[3,"DescriptorMatcher","","Type for matching keypoint descriptors",N,N],[3,"MSER","","Maximally stable extremal region extractor.",N,N],[3,"MSERBuilder","","Builder that provides defaults for MSER",N,N],[3,"SIFT","","Speeded up robust features extractor.",N,N],[3,"SIFTBuilder","","Builder that provides defaults for MSER",N,N],[3,"SURF","","Speeded up robust features extractor.",N,N],[3,"SURFBuilder","","Builder that provides defaults for MSER",N,N],[4,"KMeansCenters","","k-Means centers",N,N],[13,"Random","","Select random initial centers in each attempt.",20,N],[13,"Pp","","Use kmeans++ center initialization by Arthur and Vassilvitskii (Arthur2007).",20,N],[4,"DescriptorMatcherType","","Descriptor matcher type",N,N],[13,"BruteForce","","",21,N],[13,"BruteForceL1","","",21,N],[13,"BruteForceHamming","","",21,N],[13,"BruteForceHamming2","","",21,N],[13,"FlannBased","","",21,N],[11,"new","","Creates a new maximally stable extremal region extractor criteria.",22,[[["i32"],["termcriteria"],["i32"],["kmeanscenters"]],["self"]]],[11,"add","","Adds descriptors to a training set",22,[[["self"],["mat"]]]],[11,"cluster","","Clusters train descriptors",22,[[["self"]],["mat"]]],[11,"new","","Creates a descriptor matcher of a given type with the default parameters (using default constructor).",23,[[["descriptormatchertype"]],["descriptormatcher"]]],[11,"add","","Adds descriptors to train a CPU or GPU descriptor collection",23,[[["self"],["vec"]]]],[11,"train","","Trains a descriptor matcher",23,[[["self"]]]],[11,"is_empty","","Returns true if there are no train descriptors",23,[[["self"]],["bool"]]],[11,"match_","","Finds the best match for each descriptor from a query set",23,[[["self"],["mat"]],["vec",["dmatch"]]]],[11,"match_two","","Finds the best match for each descriptor from a query set. Unlike `match_`, train descriptors collection are passed directly",23,[[["self"],["mat"],["mat"]],["vec",["dmatch"]]]],[11,"knn_match","","Finds the k best matches for each descriptor from a query set.",23,[[["self"],["mat"],["usize"]],["vec",["vec"]]]],[11,"new","","Creates a new maximally stable extremal region extractor criteria.",24,[[["c_int"],["c_int"],["c_int"],["f64"],["f64"],["c_int"],["f64"],["f64"],["c_int"]],["self"]]],[11,"detect_regions","","Detect MSER regions.",24,N],[11,"delta","","Replace current delta with specified value",25,[[["self"],["c_int"]],["self"]]],[11,"min_area","","Replace current min_area with specified value",25,[[["self"],["c_int"]],["self"]]],[11,"max_area","","Replace current max_area with specified value",25,[[["self"],["c_int"]],["self"]]],[11,"max_variation","","Replace current max_variation with specified value",25,[[["self"],["f64"]],["self"]]],[11,"min_diversity","","Replace current min_diversity with specified value",25,[[["self"],["f64"]],["self"]]],[11,"max_evolution","","Replace current max_evolution with specified value",25,[[["self"],["c_int"]],["self"]]],[11,"area_threshold","","Replace current area_threshold with specified value",25,[[["self"],["f64"]],["self"]]],[11,"min_margin","","Replace current min_margin with specified value",25,[[["self"],["f64"]],["self"]]],[11,"edge_blur_size","","Replace current edge_blur_size with specified value",25,[[["self"],["c_int"]],["self"]]],[11,"new","","Creates a new maximally stable extremal region extractor criteria.",26,[[["c_int"],["c_int"],["f64"],["f64"],["f64"]],["self"]]],[11,"features","","Replace current features with specified value",27,[[["self"],["c_int"]],["self"]]],[11,"octave_layers","","Replace current octave_layers with specified value",27,[[["self"],["c_int"]],["self"]]],[11,"contrast_threshold","","Replace current contrast_threshold with specified value",27,[[["self"],["f64"]],["self"]]],[11,"edge_threshold","","Replace current edge_threshold with specified value",27,[[["self"],["f64"]],["self"]]],[11,"sigma","","Replace current sigma with specified value",27,[[["self"],["f64"]],["self"]]],[11,"new","","Creates a new maximally stable extremal region extractor criteria.",28,[[["f64"],["c_int"],["c_int"],["bool"],["bool"]],["self"]]],[11,"hessian_threshold","","Replace current octave_layers with specified value",29,[[["self"],["f64"]],["self"]]],[11,"octaves","","Replace current octave_layers with specified value",29,[[["self"],["c_int"]],["self"]]],[11,"octave_layers","","Replace current octave_layers with specified value",29,[[["self"],["c_int"]],["self"]]],[11,"extended","","Replace current extended with specified value",29,[[["self"],["bool"]],["self"]]],[11,"upright","","Replace current delta with specified value",29,[[["self"],["bool"]],["self"]]],[8,"Feature2D","","Basic trait for 2D image feature detectors and descriptor extractors",N,N],[10,"detect_and_compute","","Detects keypoints and computes the descriptors",30,N],[0,"hash","cv","The module brings implementations of different image hashing algorithms.",N,N],[3,"AverageHash","cv::hash","Computes average hash value of the input image",N,N],[3,"BlockMeanHash","","Image hash based on block mean",N,N],[3,"ColorMomentHash","","Image hash based on color moments",N,N],[3,"MarrHildrethHash","","Marr-Hildreth Operator Based Hash, slowest but more discriminative.",N,N],[3,"PHash","","Slower than AverageHash, but tolerant of minor modifications",N,N],[3,"RadialVarianceHash","","Image hash based on Radon transform",N,N],[8,"HashImplInterface","","",N,N],[8,"Hash","","Basic trait for all hash types",N,N],[10,"compute","","Computes image hash",31,[[["self"],["mat"]],["mat"]]],[10,"compare","","Compares two image hashes",31,[[["self"],["mat"],["mat"]],["f64"]]],[11,"new","","Creates new instance",32,[[],["self"]]],[11,"new","","Creates new instance",33,[[],["self"]]],[11,"new","","Creates new instance",34,[[],["self"]]],[11,"new","","Creates new instance",35,[[],["self"]]],[11,"new","","Creates new instance",36,[[],["self"]]],[11,"new","","Creates new instance",37,[[],["self"]]],[0,"highgui","cv","highgui: high-level GUI",N,N],[4,"WindowFlag","cv::highgui","Flags for highgui_named_window. This only supports a subset of all cv::WindowFlags because C/C++ allows enum with the same value but Rust is stricter.",N,N],[13,"Normal","","the window can be resized (no constraint) or switched to fullscreen.",38,N],[13,"Autosize","","the window is constrained by the image displayed.",38,N],[13,"Opengl","","the window is with opengl support.",38,N],[13,"FreeRatio","","the window can be resized arbitrarily (no ratio constraint).",38,N],[4,"MouseEventType","","Mouse Events",N,N],[13,"MouseMove","","Indicates that the mouse has moved over the window.",39,N],[13,"LButtonDown","","Indicates that the left mouse button is pressed.",39,N],[13,"RButtonDown","","Indicates that the right mouse button is pressed.",39,N],[13,"MButtonDown","","Indicates that the middle mouse button is pressed.",39,N],[13,"LButtonUp","","Indicates that left mouse button is released.",39,N],[13,"RButtonUp","","Indicates that right mouse button is released.",39,N],[13,"MButtonUp","","Indicates that middle mouse button is released.",39,N],[13,"LButtonClick","","Indicates that left mouse button is double clicked.",39,N],[13,"RButtonClick","","Indicates that right mouse button is double clicked.",39,N],[13,"MButtonClick","","Indicates that middle mouse button is double clicked.",39,N],[13,"MouseWheel","","Positive/negative means forward/backward scrolling.",39,N],[13,"MouseHWheel","","Positive/negative means right and left scrolling.",39,N],[5,"highgui_named_window","","Create a window that can be used as a placeholder for images and trackbars. All created windows are referred to by their names. If a window with the same name already exists, the function does nothing.",N,[[["str"],["windowflag"]],["result",["error"]]]],[5,"highgui_destroy_window","","Destroy the specified window with the given name.",N,[[["str"]]]],[5,"highgui_set_mouse_callback","","Set mouse handler for the specified window (identified by name). A callback handler should be provided and optional user_data can be passed around.",N,N],[6,"MouseCallbackData","","Pointer referring to the data used in MouseCallback",N,N],[6,"MouseCallback","","Callback function for mouse events, primarily used in highgui_set_mouse_callback",N,N],[8,"Show","","Provides some highgui functionallity",N,N],[10,"show","","Calls out to highgui to show the image, the duration is specified by `delay`.",40,[[["self"],["str"],["c_int"]],["result",["error"]]]],[0,"imgcodecs","cv","Image file reading and writing, see OpenCV imgcodecs.",N,N],[4,"ImageReadMode","cv::imgcodecs","ImreadModes. See documentation for detauls",N,N],[13,"Unchanged","","If set, return the loaded image as is (with alpha channel, otherwise it gets cropped",41,N],[13,"Grayscale","","If set, always convert image to the single channel grayscale image.",41,N],[13,"Color","","If set, always convert image to the 3 channel BGR color image.",41,N],[13,"AnyDepth","","If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.",41,N],[13,"AnyColor","","If set, the image is read in any possible color format.",41,N],[13,"LoadGdal","","If set, use the gdal driver for loading the image.",41,N],[13,"ReducedGrayscale2","","If set, always convert image to the single channel grayscale image and the image size reduced 1/2.",41,N],[13,"ReducedColor2","","If set, always convert image to the 3 channel BGR color image and the image size reduced 1/2.",41,N],[13,"ReducedGrayscale4","","If set, always convert image to the single channel grayscale image and the image size reduced 1/4.",41,N],[13,"ReducedColor4","","If set, always convert image to the 3 channel BGR color image and the image size reduced 1/4.",41,N],[13,"ReducedGrayscale8","","If set, always convert image to the single channel grayscale image and the image size reduced 1/8.",41,N],[13,"ReducedColor8","","If set, always convert image to the 3 channel BGR color image and the image size reduced 1/8.",41,N],[4,"ImageWriteMode","","Imwrite flags. See documentation for detauls",N,N],[13,"JpegQuality","","For JPEG, it can be a quality from 0 to 100 (the higher is the better). Default value is 95.",42,N],[13,"JpegProgressive","","Enable JPEG features, 0 or 1, default is False.",42,N],[13,"JpegOptimize","","Enable JPEG features, 0 or 1, default is False.",42,N],[13,"JpegRstInterval","","JPEG restart interval, 0 - 65535, default is 0 - no restart.",42,N],[13,"JpegLumaQuality","","Separate luma quality level, 0 - 100, default is 0 - don't use.",42,N],[13,"JpegChromaQuality","","Separate chroma quality level, 0 - 100, default is 0 - don't use.",42,N],[13,"PngCompression","","For PNG, it can be the compression level from 0 to 9. A higher value means a smaller size and longer compression time. Default value is 3. Also strategy is changed to IMWRITE_PNG_STRATEGY_DEFAULT (Z_DEFAULT_STRATEGY).",42,N],[13,"PngStrategy","","One of cv::ImwritePNGFlags, default is IMWRITE_PNG_STRATEGY_DEFAULT.",42,N],[13,"PngBilevel","","Binary level PNG, 0 or 1, default is 0.",42,N],[13,"PxmBinary","","For PPM, PGM, or PBM, it can be a binary format flag, 0 or 1. Default value is 1.",42,N],[13,"WebpQuality","","For WEBP, it can be a quality from 1 to 100 (the higher is the better). By default (without any parameter) and for quality above 100 the lossless compression is used.",42,N],[13,"PamTupletype","","For PAM, sets the TUPLETYPE field to the corresponding string value that is defined for the format",42,N],[4,"ImageWritePngStrategy","","Imwrite PNG flag. See documentation for detauls",N,N],[13,"Default","","Use this value for normal data.",43,N],[13,"Filtered","","Use this value for data produced by a filter (or predictor).Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better.",43,N],[13,"HuffmanOnly","","Use this value to force Huffman encoding only (no string match).",43,N],[13,"RLE","","Use this value to limit match distances to one (run-length encoding).",43,N],[13,"Fixed","","Using this value prevents the use of dynamic Huffman codes, allowing for a simpler decoder for special applications.",43,N],[0,"imgproc","cv","Image processing, see OpenCV imgproc.",N,N],[4,"HistogramComparisionMethod","cv::imgproc","Possible methods for histogram comparision method",N,N],[13,"Correlation","","HISTCMP_CORREL",44,N],[13,"ChiSquare","","HISTCMP_CHISQR",44,N],[13,"Intersection","","HISTCMP_INTERSECT",44,N],[13,"Bhattacharyya","","HISTCMP_BHATTACHARYYA and HISTCMP_HELLINGER",44,N],[13,"ChiSquareAlternative","","HISTCMP_CHISQR_ALT",44,N],[13,"KullbackLeiblerDivergence","","HISTCMP_KL_DIV",44,N],[4,"ThresholdType","","ThresholdTypes used in threshold.",N,N],[13,"Binary","","",45,N],[13,"BinaryInv","","",45,N],[13,"Trunc","","",45,N],[13,"ToZero","","",45,N],[13,"ToZeroInv","","",45,N],[13,"Mask","","",45,N],[13,"Otsu","","",45,N],[13,"Triangle","","",45,N],[4,"ColorConversion","","Color conversion code used in cvt_color.",N,N],[13,"BGR2BGRA","","",46,N],[13,"BGRA2BGR","","",46,N],[13,"BGR2RGBA","","",46,N],[13,"RGBA2BGR","","",46,N],[13,"BGR2RGB","","",46,N],[13,"BGRA2RGBA","","",46,N],[13,"BGR2GRAY","","",46,N],[13,"RGB2GRAY","","",46,N],[13,"GRAY2BGR","","",46,N],[13,"GRAY2BGRA","","",46,N],[13,"BGRA2GRAY","","",46,N],[13,"RGBA2GRAY","","",46,N],[13,"BGR2BGR565","","",46,N],[13,"RGB2BGR565","","",46,N],[13,"BGR5652BGR","","",46,N],[13,"BGR5652RGB","","",46,N],[13,"BGRA2BGR565","","",46,N],[13,"RGBA2BGR565","","",46,N],[13,"BGR5652BGRA","","",46,N],[13,"BGR5652RGBA","","",46,N],[13,"GRAY2BGR565","","",46,N],[13,"BGR5652GRAY","","",46,N],[13,"BGR2BGR555","","",46,N],[13,"RGB2BGR555","","",46,N],[13,"BGR5552BGR","","",46,N],[13,"BGR5552RGB","","",46,N],[13,"BGRA2BGR555","","",46,N],[13,"RGBA2BGR555","","",46,N],[13,"BGR5552BGRA","","",46,N],[13,"BGR5552RGBA","","",46,N],[13,"GRAY2BGR555","","",46,N],[13,"BGR5552GRAY","","",46,N],[13,"BGR2XYZ","","",46,N],[13,"RGB2XYZ","","",46,N],[13,"XYZ2BGR","","",46,N],[13,"XYZ2RGB","","",46,N],[13,"BGR2YCrCb","","",46,N],[13,"RGB2YCrCb","","",46,N],[13,"YCrCb2BGR","","",46,N],[13,"YCrCb2RGB","","",46,N],[13,"BGR2HSV","","",46,N],[13,"RGB2HSV","","",46,N],[13,"BGR2Lab","","",46,N],[13,"RGB2Lab","","",46,N],[13,"BGR2Luv","","",46,N],[13,"RGB2Luv","","",46,N],[13,"BGR2HLS","","",46,N],[13,"RGB2HLS","","",46,N],[13,"HSV2BGR","","",46,N],[13,"HSV2RGB","","",46,N],[13,"Lab2BGR","","",46,N],[13,"Lab2RGB","","",46,N],[13,"Luv2BGR","","",46,N],[13,"Luv2RGB","","",46,N],[13,"HLS2BGR","","",46,N],[13,"HLS2RGB","","",46,N],[13,"BGR2HSV_FULL","","",46,N],[13,"RGB2HSV_FULL","","",46,N],[13,"BGR2HLS_FULL","","",46,N],[13,"RGB2HLS_FULL","","",46,N],[13,"HSV2BGR_FULL","","",46,N],[13,"HSV2RGB_FULL","","",46,N],[13,"HLS2BGR_FULL","","",46,N],[13,"HLS2RGB_FULL","","",46,N],[13,"LBGR2Lab","","",46,N],[13,"LRGB2Lab","","",46,N],[13,"LBGR2Luv","","",46,N],[13,"LRGB2Luv","","",46,N],[13,"Lab2LBGR","","",46,N],[13,"Lab2LRGB","","",46,N],[13,"Luv2LBGR","","",46,N],[13,"Luv2LRGB","","",46,N],[13,"BGR2YUV","","",46,N],[13,"RGB2YUV","","",46,N],[13,"YUV2BGR","","",46,N],[13,"YUV2RGB","","",46,N],[13,"YUV2RGB_NV12","","",46,N],[13,"YUV2BGR_NV12","","",46,N],[13,"YUV2RGB_NV21","","",46,N],[13,"YUV2BGR_NV21","","",46,N],[13,"YUV2RGBA_NV12","","",46,N],[13,"YUV2BGRA_NV12","","",46,N],[13,"YUV2RGBA_NV21","","",46,N],[13,"YUV2BGRA_NV21","","",46,N],[13,"YUV2RGB_YV12","","",46,N],[13,"YUV2BGR_YV12","","",46,N],[13,"YUV2RGB_IYUV","","",46,N],[13,"YUV2BGR_IYUV","","",46,N],[13,"YUV2RGBA_YV12","","",46,N],[13,"YUV2BGRA_YV12","","",46,N],[13,"YUV2RGBA_IYUV","","",46,N],[13,"YUV2BGRA_IYUV","","",46,N],[13,"YUV2GRAY_420","","",46,N],[13,"YUV2RGB_UYVY","","",46,N],[13,"YUV2BGR_UYVY","","",46,N],[13,"YUV2RGBA_UYVY","","",46,N],[13,"YUV2BGRA_UYVY","","",46,N],[13,"YUV2RGB_YUY2","","",46,N],[13,"YUV2BGR_YUY2","","",46,N],[13,"YUV2RGB_YVYU","","",46,N],[13,"YUV2BGR_YVYU","","",46,N],[13,"YUV2RGBA_YUY2","","",46,N],[13,"YUV2BGRA_YUY2","","",46,N],[13,"YUV2RGBA_YVYU","","",46,N],[13,"YUV2BGRA_YVYU","","",46,N],[13,"YUV2GRAY_UYVY","","",46,N],[13,"YUV2GRAY_YUY2","","",46,N],[13,"RGBA2mRGBA","","",46,N],[13,"mRGBA2RGBA","","",46,N],[13,"RGB2YUV_I420","","",46,N],[13,"BGR2YUV_I420","","",46,N],[13,"RGBA2YUV_I420","","",46,N],[13,"BGRA2YUV_I420","","",46,N],[13,"RGB2YUV_YV12","","",46,N],[13,"BGR2YUV_YV12","","",46,N],[13,"RGBA2YUV_YV12","","",46,N],[13,"BGRA2YUV_YV12","","",46,N],[13,"BayerBG2BGR","","",46,N],[13,"BayerGB2BGR","","",46,N],[13,"BayerRG2BGR","","",46,N],[13,"BayerGR2BGR","","",46,N],[13,"BayerBG2GRAY","","",46,N],[13,"BayerGB2GRAY","","",46,N],[13,"BayerRG2GRAY","","",46,N],[13,"BayerGR2GRAY","","",46,N],[13,"BayerBG2BGR_VNG","","",46,N],[13,"BayerGB2BGR_VNG","","",46,N],[13,"BayerRG2BGR_VNG","","",46,N],[13,"BayerGR2BGR_VNG","","",46,N],[13,"BayerBG2BGR_EA","","",46,N],[13,"BayerGB2BGR_EA","","",46,N],[13,"BayerRG2BGR_EA","","",46,N],[13,"BayerGR2BGR_EA","","",46,N],[13,"COLORCVT_MAX","","",46,N],[4,"InterpolationFlag","","Interpolation algorithm",N,N],[13,"InterNearst","","nearest neighbor interpolation",47,N],[13,"InterLinear","","bilinear interpolation",47,N],[13,"InterCubic","","bicubic interpolation",47,N],[13,"InterArea","","resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire'-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.",47,N],[13,"InterLanczos4","","Lanczos interpolation over 8x8 neighborhood",47,N],[13,"InterLinearExact","","Bit exact bilinear interpolation",47,N],[13,"InterMax","","mask for interpolation codes",47,N],[13,"WarpFillOutliers","","flag, fills all of the destination image pixels. If some of them correspond to outliers in the source image, they are set to zero",47,N],[13,"WarpInverseMap","","flag, inverse transformation",47,N],[0,"mat","cv","Mat",N,N],[3,"Mat","cv::mat","The class `Mat` represents an n-dimensional dense numerical single-channel or multi-channel array. It can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel volumes, vector fields, point clouds, tensors, histograms",N,N],[12,"cols","","Number of columns",48,N],[12,"rows","","Number of rows",48,N],[12,"depth","","Depth of this mat (it should be the type).",48,N],[12,"channels","","Channels of this mat",48,N],[4,"CMat","","The class `CMat` is used as a pointer to represent the Mat opencv structure",N,N],[4,"BorderType","","Various border types, image boundaries are denoted with `|`.",N,N],[13,"Constant","","`iiiiii|abcdefgh|iiiiiii`  with some specified `i`",49,N],[13,"Replicate","","`aaaaaa|abcdefgh|hhhhhhh`",49,N],[13,"Reflect","","`fedcba|abcdefgh|hgfedcb`",49,N],[13,"Wrap","","`cdefgh|abcdefgh|abcdefg`",49,N],[13,"Reflect101","","`gfedcb|abcdefgh|gfedcba`",49,N],[13,"Transparent","","`uvwxyz|abcdefgh|ijklmno`",49,N],[13,"Isolated","","Do not look outside of ROI.",49,N],[11,"from_file_storage","","Loads `Mat` from file storage",48,[[["p"],["str"]],["result",["mat","error"]]]],[11,"new","","Creates an empty `Mat` struct.",48,[[],["mat"]]],[11,"from_buffer","","Creates a new `Mat` from buffer. Note that internally opencv function won't take ownership of the Mat, but when we call `drop`, it will deallocate the memory. To prevent double-freeing, you must `mem::forget` it after use.",48,N],[11,"with_size","","Create an empty `Mat` with specific size (rows, cols and types).",48,[[["c_int"],["c_int"],["c_int"]],["self"]]],[11,"zeros","","Create an empty `Mat` with specific size (rows, cols and types).",48,[[["c_int"],["c_int"],["c_int"]],["self"]]],[11,"data","","Returns the raw data (as a `u8` pointer)",48,N],[11,"total","","Returns the total number of array elements. The method returns the number of array elements (a number of pixels if the array represents an image). For example, images with 1920x1080 resolution will return 2073600.",48,[[["self"]],["usize"]]],[11,"elem_size","","Returns the matrix element size in bytes.",48,[[["self"]],["usize"]]],[11,"elem_size1","","Returns the size of each matrix element channel in bytes.",48,[[["self"]],["usize"]]],[11,"step1","","Returns a normalized step.",48,[[["self"],["c_int"]],["usize"]]],[11,"size","","Returns the size of this matrix.",48,[[["self"]],["size2i"]]],[11,"is_valid","","Check if the `Mat` is valid or not.",48,[[["self"]],["bool"]]],[11,"roi","","Return a region of interest from a `Mat` specfied by a `Rect`.",48,[[["self"],["rect"]],["mat"]]],[11,"flip","","Flips an image around vertical, horizontal, or both axes.",48,[[["self"],["flipcode"]]]],[11,"cv_type","","Returns the images type. For supported types, please see CvType.",48,[[["self"]],["cvtype"]]],[11,"eye","","Returns an identity matrix of the specified size and type.",48,[[["i32"],["i32"],["cvtype"]],["mat"]]],[11,"at","","Returns individual pixel (element) information within the Mat. This function may need type annotation to assist `FromBytes` trait.",48,[[["self"],["i32"]],["t"]]],[11,"at2","","Returns individual pixel (element) information within the Mat. This function may need type annotation to assist `FromBytes` trait.",48,[[["self"],["i32"],["i32"]],["t"]]],[11,"at3","","Returns individual pixel (element) information within the Mat. This function may need type annotation to assist `FromBytes` trait.",48,[[["self"],["i32"],["i32"],["i32"]],["t"]]],[11,"in_range","","Checks if Mat elements lie between the elements of two other arrays (lowerb and upperb). The output Mat has the same size as `self` and CV_8U type.",48,[[["self"],["scalar"],["scalar"]],["mat"]]],[11,"min_max_loc","","Finds the global minimum and maximum in an array.",48,N],[11,"mix_channels","","Copy specified channels from `self` to the specified channels of output `Mat`.",48,[[["self"],["usize"],["usize"],["t"]],["mat"]]],[11,"normalize","","Normalize the Mat according to the normalization type.",48,[[["self"],["f64"],["f64"],["normtype"]],["mat"]]],[11,"count_non_zero","","Counts non-zero array elements.",48,[[["self"]],["c_int"]]],[11,"copy_make_border","","Forms a border around an image.",48,[[["self"],["i32"],["i32"],["i32"],["i32"],["bordertype"],["scalar"]],["mat"]]],[18,"Default","","same as Reflect101",49,N],[0,"objdetect","cv","Various object detection algorithms, such as Haar feature-based cascade classifier for object detection and histogram of oriented gradients (HOG).",N,N],[3,"CascadeClassifier","cv::objdetect","Cascade classifier class for object detection.",N,N],[3,"SvmDetector","","SvmDetector",N,N],[3,"HogParams","","Parameters that controls the behavior of HOG.",N,N],[12,"win_size","","Detection window size. Align to block size and block stride. The default is 64x128, trained the same as original paper.",50,N],[12,"block_size","","Block size in pixels. Align to cell size. Only (16,16) is supported for now (at least for GPU).",50,N],[12,"block_stride","","Block stride. It must be a multiple of cell size.",50,N],[12,"cell_size","","Cell size. Only (8, 8) is supported for now.",50,N],[12,"nbins","","Number of bins. Only 9 bins per cell are supported for now.",50,N],[12,"win_sigma","","Gaussian smoothing window parameter. Default -1 for CPU and 4.0 for GPU.",50,N],[12,"l2hys_threshold","","L2-Hys normalization method shrinkage. Default 0.2.",50,N],[12,"gamma_correction","","Flag to specify whether the gamma correction preprocessing is required or not. Default false.",50,N],[12,"nlevels","","Maximum number of detection window increases (HOG scales). Default: 64.",50,N],[12,"hit_threshold","","Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specfied in the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here.",50,N],[12,"win_stride","","Window stride. It must be a multiple of block stride.",50,N],[12,"padding","","Padding",50,N],[12,"scale","","Coefficient of the detection window increase.",50,N],[12,"group_threshold","","Coefficient to regulate the similarity threshold. When detected, some objects can be covered by many rectangles. 0 means not to perform grouping.",50,N],[12,"use_meanshift_grouping","","The useMeanShiftGrouping parameter is a boolean indicating whether or not mean-shift grouping should be performed to handle potential overlapping bounding boxes. While this value should not be set and users should employ non-maxima suppression instead, we support setting it as a library function.",50,N],[12,"final_threshold","","The `finalThreshold` parameter is mainly used to select the clusters that have at least `finalThreshold + 1` rectangles. This parameter is passed when meanShift is enabled; the function rejects the small clusters containing less than or equal to `finalThreshold` rectangles, computes the average rectangle size for the rest of the accepted clusters and adds those to the output rectangle list.",50,N],[3,"HogDescriptor","","`HogDescriptor` implements Histogram of Oriented Gradients.",N,N],[12,"params","","Hog parameters.",51,N],[4,"CSvmDetector","","Opaque type for C/C++ SvmDetector object",N,N],[8,"ObjectDetect","","An object detect trait.",N,N],[10,"detect","","Detects the object inside this image and returns a list of detections with their confidence.",52,[[["self"],["mat"]],["vec"]]],[11,"new","","Creates a cascade classifier, uninitialized. Before use, call load.",53,[[],["cascadeclassifier"]]],[11,"from_path","","Creates a cascade classifier using the model specified.",53,[[["p"]],["result",["error"]]]],[11,"load","","Loads the classifier model from a path.",53,[[["self"],["p"]],["result",["error"]]]],[11,"detect_multiscale","","The default detection uses scale factor 1.1, minNeighbors 3, no min size or max size.",53,[[["self"],["mat"]],["vec",["rect"]]]],[11,"detect_with_params","","Detects the object using parameters specified.",53,[[["self"],["mat"],["f32"],["c_int"],["size2i"],["size2i"]],["vec",["rect"]]]],[11,"default_people_detector","","The built-in people detector.",54,[[],["svmdetector"]]],[11,"daimler_people_detector","","Returns the Daimler people detector.",54,[[],["svmdetector"]]],[11,"with_params","","Creates a HogDescriptor with provided parameters.",51,[[["hogparams"]],["hogdescriptor"]]],[11,"set_svm_detector","","Sets the SVM detector.",51,[[["self"],["svmdetector"]]]],[0,"video","cv","Video Analysis, see OpenCV video",N,N],[0,"tracking","cv::video","Object Tracking, see OpenCV video track",N,N],[11,"camshift","cv::mat","Finds an object center, size, and orientation; returns as `RotatedRect`.",48,[[["self"],["rect"],["termcriteria"]],["rotatedrect"]]],[0,"analysis","cv::video","Motion Analysis, see OpenCV video motion",N,N],[0,"videoio","cv","Media I/O, see OpenCV videoio",N,N],[3,"VideoCapture","cv::videoio","Video capturing from video files, image sequences or cameras.",N,N],[3,"VideoWriter","","`VideoWriter` provides easy access to write videos to files. -On Linux FFMPEG is used to write videos; -On Windows FFMPEG or VFW is used; -On MacOSX QTKit is used.",N,N],[4,"CapProp","","Video capture's property identifier.",N,N],[13,"PosMsec","","Current position of the video file in milliseconds or video capture timestamp.",55,N],[13,"PosFrames","","0-based index of the frame to be decoded/captured next.",55,N],[13,"PosAviRatio","","Relative position of the video file: 0 - start of the film, 1 - end of the film.",55,N],[13,"FrameWidth","","Width of the frames in the video stream.",55,N],[13,"FrameHeight","","Height of the frames in the video stream.",55,N],[13,"Fps","","Frame rate.",55,N],[13,"Fourcc","","4-character code of codec.",55,N],[13,"FrameCount","","Number of frames in the video file.",55,N],[13,"Format","","Format of the Mat objects returned by retrieve() .",55,N],[13,"Mode","","Backend-specific value indicating the current capture mode.",55,N],[13,"Brightness","","Brightness of the image (only for cameras).",55,N],[13,"Contrast","","Contrast of the image (only for cameras).",55,N],[13,"Saturation","","Saturation of the image (only for cameras).",55,N],[13,"Hue","","Hue of the image (only for cameras).",55,N],[13,"Gain","","Gain of the image (only for cameras).",55,N],[13,"Exposure","","Exposure (only for cameras).",55,N],[13,"ConvertRgb","","Boolean flags indicating whether images should be converted to RGB.",55,N],[13,"WhiteBalanceBlueU","","Currently not supported",55,N],[13,"Rectification","","Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend currently)",55,N],[13,"Monochrome","","",55,N],[13,"Sharpness","","",55,N],[13,"AutoExposure","","",55,N],[13,"Gamma","","",55,N],[13,"Temperature","","",55,N],[13,"Trigger","","",55,N],[13,"TriggerDelay","","",55,N],[13,"WhiteBalanceRedV","","",55,N],[13,"Zoom","","",55,N],[13,"Focus","","",55,N],[13,"Guid","","",55,N],[13,"IsoSpeed","","",55,N],[13,"Backlight","","",55,N],[13,"Pan","","",55,N],[13,"Tilt","","",55,N],[13,"Roll","","",55,N],[13,"Iris","","",55,N],[13,"Settings","","",55,N],[13,"Buffersize","","",55,N],[13,"Autofocus","","",55,N],[4,"VideoWriterProperty","","`VideoWriter`'s property identifier.",N,N],[13,"Quality","","Current quality of the encoded videostream.",56,N],[13,"FrameBytes","","(Read-only) Size of just encoded video frame; note that the encoding order may be different from representation order.",56,N],[13,"NStripes","","Number of stripes for parallel encoding",56,N],[5,"codec_name_from_4cc","","Converts from four character code to `u32`",N,[[["str"]],["result",["u32","error"]]]],[5,"codec_name_to_4cc","","Converts to four character code from `u32`.",N,[[["u32"]],["string"]]],[11,"new","","Creates a capture device with specified camera id. If there is a single camera connected, just pass 0.",57,[[["c_int"]],["self"]]],[11,"from_path","","Creates a capture device with the path of a video file (eg. video.avi). This also supports image sequence, eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...).",57,[[["str"]],["self"]]],[11,"from_pipeline","","Create a capture device from a gstreamer pipeline (eg. gst-launch-1.0 v4l2src ! videoconvert ! appsink).",57,[[["str"]],["self"]]],[11,"is_open","","Returns true if video capturing has been initialized already.",57,[[["self"]],["bool"]]],[11,"read","","Grabs, decodes and returns the next video frame. `read` combines `VideoCapture::grab` and `VideoCapture::retrieve` in one call. This is the most convenient method for reading video files or capturing data from decode and return the just grabbed frame.",57,[[["self"]],["option",["mat"]]]],[11,"set","","Sets a property in the `VideoCapture`.",57,[[["self"],["capprop"],["f64"]],["bool"]]],[11,"get","","Gets a property in the `VideoCapture`.",57,[[["self"],["capprop"]],["option",["f64"]]]],[11,"new","","`VideoWriter` constructor. -path – Name of the output video file. -fourcc – 4-character code of codec used to compress the frames. For  example, VideoWriter::fourcc('P','I','M','1') is a MPEG-1 codec,  VideoWriter::fourcc('M','J','P','G') is a motion-jpeg codec etc. List  of codes can be obtained at Video Codecs by FOURCC page. -fps – Framerate of the created video stream. -frame_size – Size of the video frames. -is_color – If it is not zero, the encoder will expect and encode color  frames, otherwise it will work with grayscale frames (the flag is  currently supported on Windows only).",58,[[["str"],["c_int"],["f64"],["size2i"],["bool"]],["videowriter"]]],[11,"open","","`VideoWriter` constructor. -path – Name of the output video file. -fourcc – 4-character code of codec used to compress the frames. For  example, VideoWriter::fourcc('P','I','M','1') is a MPEG-1 codec,  VideoWriter::fourcc('M','J','P','G') is a motion-jpeg codec etc. List  of codes can be obtained at Video Codecs by FOURCC page. -fps – Framerate of the created video stream. -frame_size – Size of the video frames. -is_color – If it is not zero, the encoder will expect and encode color  frames, otherwise it will work with grayscale frames (the flag is  currently supported on Windows only).",58,[[["self"],["str"],["c_int"],["f64"],["size2i"],["bool"]],["bool"]]],[11,"write","","Writes the specified image to video file. It must have the same size as has been specified when opening the video writer.",58,[[["self"],["mat"]]]],[11,"is_open","","Returns true if video writer has been initialized already.",58,[[["self"]],["bool"]]],[11,"set","","Sets a property in the `VideoWriter`. Note: `VideoWriterProperty::FrameBytes` is read-only.",58,[[["self"],["videowriterproperty"],["f64"]],["bool"]]],[11,"get","","Gets a property in the `VideoWriter`.",58,[[["self"],["videowriterproperty"]],["option",["f64"]]]],[11,"into","cv::core","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"into","cv::cuda","",16,[[["self"]],["u"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"into","","",59,[[["self"]],["u"]]],[11,"to_owned","","",59,[[["self"]],["t"]]],[11,"clone_into","","",59,N],[11,"from","","",59,[[["t"]],["t"]]],[11,"try_from","","",59,[[["u"]],["result"]]],[11,"borrow","","",59,[[["self"]],["t"]]],[11,"get_type_id","","",59,[[["self"]],["typeid"]]],[11,"try_into","","",59,[[["self"]],["result"]]],[11,"borrow_mut","","",59,[[["self"]],["t"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"to_owned","","",60,[[["self"]],["t"]]],[11,"clone_into","","",60,N],[11,"from","","",60,[[["t"]],["t"]]],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"into","","",61,[[["self"]],["u"]]],[11,"to_owned","","",61,[[["self"]],["t"]]],[11,"clone_into","","",61,N],[11,"from","","",61,[[["t"]],["t"]]],[11,"try_from","","",61,[[["u"]],["result"]]],[11,"borrow","","",61,[[["self"]],["t"]]],[11,"get_type_id","","",61,[[["self"]],["typeid"]]],[11,"try_into","","",61,[[["self"]],["result"]]],[11,"borrow_mut","","",61,[[["self"]],["t"]]],[11,"into","cv::errors","",19,[[["self"]],["u"]]],[11,"to_string","","",19,[[["self"]],["string"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"as_fail","","",19,[[["self"]],["fail"]]],[11,"into","cv::features2d","",22,[[["self"]],["u"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"into","","",62,[[["self"]],["u"]]],[11,"to_owned","","",62,[[["self"]],["t"]]],[11,"clone_into","","",62,N],[11,"from","","",62,[[["t"]],["t"]]],[11,"try_from","","",62,[[["u"]],["result"]]],[11,"borrow","","",62,[[["self"]],["t"]]],[11,"get_type_id","","",62,[[["self"]],["typeid"]]],[11,"try_into","","",62,[[["self"]],["result"]]],[11,"borrow_mut","","",62,[[["self"]],["t"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"to_owned","","",25,[[["self"]],["t"]]],[11,"clone_into","","",25,N],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"to_owned","","",27,[[["self"]],["t"]]],[11,"clone_into","","",27,N],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"to_owned","","",29,[[["self"]],["t"]]],[11,"clone_into","","",29,N],[11,"from","","",29,[[["t"]],["t"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,N],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"compute","cv::hash","Computes image hash",32,[[["self"],["mat"]],["mat"]]],[11,"compare","","Compares two image hashes",32,[[["self"],["mat"],["mat"]],["f64"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"from","","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"compute","","Computes image hash",33,[[["self"],["mat"]],["mat"]]],[11,"compare","","Compares two image hashes",33,[[["self"],["mat"],["mat"]],["f64"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"compute","","Computes image hash",34,[[["self"],["mat"]],["mat"]]],[11,"compare","","Compares two image hashes",34,[[["self"],["mat"],["mat"]],["f64"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"compute","","Computes image hash",35,[[["self"],["mat"]],["mat"]]],[11,"compare","","Compares two image hashes",35,[[["self"],["mat"],["mat"]],["f64"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"from","","",35,[[["t"]],["t"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"compute","","Computes image hash",36,[[["self"],["mat"]],["mat"]]],[11,"compare","","Compares two image hashes",36,[[["self"],["mat"],["mat"]],["f64"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"from","","",36,[[["t"]],["t"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"compute","","Computes image hash",37,[[["self"],["mat"]],["mat"]]],[11,"compare","","Compares two image hashes",37,[[["self"],["mat"],["mat"]],["f64"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"into","cv::highgui","",38,[[["self"]],["u"]]],[11,"to_owned","","",38,[[["self"]],["t"]]],[11,"clone_into","","",38,N],[11,"from","","",38,[[["t"]],["t"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"to_owned","","",39,[[["self"]],["t"]]],[11,"clone_into","","",39,N],[11,"from","","",39,[[["t"]],["t"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"into","cv::imgcodecs","",41,[[["self"]],["u"]]],[11,"to_owned","","",41,[[["self"]],["t"]]],[11,"clone_into","","",41,N],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"to_owned","","",43,[[["self"]],["t"]]],[11,"clone_into","","",43,N],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"into","cv::imgproc","",44,[[["self"]],["u"]]],[11,"to_owned","","",44,[[["self"]],["t"]]],[11,"clone_into","","",44,N],[11,"from","","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"to_owned","","",45,[[["self"]],["t"]]],[11,"clone_into","","",45,N],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"to_owned","","",46,[[["self"]],["t"]]],[11,"clone_into","","",46,N],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"to_owned","","",47,[[["self"]],["t"]]],[11,"clone_into","","",47,N],[11,"from","","",47,[[["t"]],["t"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"into","cv::mat","",48,[[["self"]],["u"]]],[11,"to_owned","","",48,[[["self"]],["t"]]],[11,"clone_into","","",48,N],[11,"from","","",48,[[["t"]],["t"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"into","","",63,[[["self"]],["u"]]],[11,"to_owned","","",63,[[["self"]],["t"]]],[11,"clone_into","","",63,N],[11,"from","","",63,[[["t"]],["t"]]],[11,"try_from","","",63,[[["u"]],["result"]]],[11,"borrow","","",63,[[["self"]],["t"]]],[11,"get_type_id","","",63,[[["self"]],["typeid"]]],[11,"try_into","","",63,[[["self"]],["result"]]],[11,"borrow_mut","","",63,[[["self"]],["t"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"to_owned","","",49,[[["self"]],["t"]]],[11,"clone_into","","",49,N],[11,"from","","",49,[[["t"]],["t"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"into","cv::objdetect","",53,[[["self"]],["u"]]],[11,"from","","",53,[[["t"]],["t"]]],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"into","","",54,[[["self"]],["u"]]],[11,"from","","",54,[[["t"]],["t"]]],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"to_owned","","",50,[[["self"]],["t"]]],[11,"clone_into","","",50,N],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"from","","",51,[[["t"]],["t"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"into","","",64,[[["self"]],["u"]]],[11,"to_owned","","",64,[[["self"]],["t"]]],[11,"clone_into","","",64,N],[11,"from","","",64,[[["t"]],["t"]]],[11,"try_from","","",64,[[["u"]],["result"]]],[11,"borrow","","",64,[[["self"]],["t"]]],[11,"get_type_id","","",64,[[["self"]],["typeid"]]],[11,"try_into","","",64,[[["self"]],["result"]]],[11,"borrow_mut","","",64,[[["self"]],["t"]]],[11,"into","cv::videoio","",57,[[["self"]],["u"]]],[11,"from","","",57,[[["t"]],["t"]]],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"into","","",58,[[["self"]],["u"]]],[11,"from","","",58,[[["t"]],["t"]]],[11,"try_from","","",58,[[["u"]],["result"]]],[11,"borrow","","",58,[[["self"]],["t"]]],[11,"get_type_id","","",58,[[["self"]],["typeid"]]],[11,"try_into","","",58,[[["self"]],["result"]]],[11,"borrow_mut","","",58,[[["self"]],["t"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"to_owned","","",55,[[["self"]],["t"]]],[11,"clone_into","","",55,N],[11,"from","","",55,[[["t"]],["t"]]],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"to_owned","","",56,[[["self"]],["t"]]],[11,"clone_into","","",56,N],[11,"from","","",56,[[["t"]],["t"]]],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"detect_and_compute","cv::features2d","",26,N],[11,"detect_and_compute","","",28,N],[11,"show","cv::mat","",48,[[["self"],["str"],["c_int"]],["result",["error"]]]],[11,"detect","cv::cuda","",17,[[["self"],["mat"]],["vec"]]],[11,"detect","","",18,[[["self"],["mat"]],["vec"]]],[11,"detect","cv::objdetect","",53,[[["self"],["mat"]],["vec"]]],[11,"detect","","",51,[[["self"],["mat"]],["vec"]]],[11,"into","cv::features2d","",25,[[["self"]],["mser"]]],[11,"into","","",27,[[["self"]],["sift"]]],[11,"into","","",29,[[["self"]],["surf"]]],[11,"into","cv::mat","",48,[[["self"]],["cmat"]]],[11,"default","cv::core","",0,[[],["keypoint"]]],[11,"default","","",13,[[],["scalar"]]],[11,"default","","",1,[[],["point2i"]]],[11,"default","","",2,[[],["point2f"]]],[11,"default","","",3,[[],["size2i"]]],[11,"default","","",4,[[],["size2f"]]],[11,"default","","",5,[[],["rect"]]],[11,"default","","",6,[[],["rect2f"]]],[11,"default","","",14,[[],["rotatedrect"]]],[11,"default","cv::cuda","",17,[[],["gpuhog"]]],[11,"default","cv::features2d","",62,[[],["dmatch"]]],[11,"default","","",25,[[],["mserbuilder"]]],[11,"default","","",27,[[],["siftbuilder"]]],[11,"default","","",29,[[],["surfbuilder"]]],[11,"default","cv::objdetect","",50,[[],["hogparams"]]],[11,"default","","",51,[[],["hogdescriptor"]]],[11,"default","cv::videoio","",58,[[],["videowriter"]]],[11,"eq","cv::core","",5,[[["self"],["rect"]],["bool"]]],[11,"ne","","",5,[[["self"],["rect"]],["bool"]]],[11,"eq","","",7,[[["self"],["linetype"]],["bool"]]],[11,"eq","","",8,[[["self"],["flipcode"]],["bool"]]],[11,"eq","","",9,[[["self"],["cvtype"]],["bool"]]],[11,"eq","","",10,[[["self"],["normtype"]],["bool"]]],[11,"eq","","",11,[[["self"],["termtype"]],["bool"]]],[11,"eq","cv::highgui","",38,[[["self"],["windowflag"]],["bool"]]],[11,"eq","","",39,[[["self"],["mouseeventtype"]],["bool"]]],[11,"eq","cv::imgcodecs","",41,[[["self"],["imagereadmode"]],["bool"]]],[11,"eq","","",42,[[["self"],["imagewritemode"]],["bool"]]],[11,"eq","","",43,[[["self"],["imagewritepngstrategy"]],["bool"]]],[11,"eq","cv::imgproc","",44,[[["self"],["histogramcomparisionmethod"]],["bool"]]],[11,"eq","","",45,[[["self"],["thresholdtype"]],["bool"]]],[11,"eq","","",46,[[["self"],["colorconversion"]],["bool"]]],[11,"eq","","",47,[[["self"],["interpolationflag"]],["bool"]]],[11,"eq","cv::videoio","",55,[[["self"],["capprop"]],["bool"]]],[11,"eq","","",56,[[["self"],["videowriterproperty"]],["bool"]]],[11,"from","cv::mat","",48,[[["gpumat"]],["mat"]]],[11,"from","cv::cuda","",16,[[["mat"]],["gpumat"]]],[11,"clone","cv::core","",0,[[["self"]],["keypoint"]]],[11,"clone","","",13,[[["self"]],["scalar"]]],[11,"clone","","",1,[[["self"]],["point2i"]]],[11,"clone","","",2,[[["self"]],["point2f"]]],[11,"clone","","",3,[[["self"]],["size2i"]]],[11,"clone","","",4,[[["self"]],["size2f"]]],[11,"clone","","",5,[[["self"]],["rect"]]],[11,"clone","","",6,[[["self"]],["rect2f"]]],[11,"clone","","",7,[[["self"]],["linetype"]]],[11,"clone","","",8,[[["self"]],["flipcode"]]],[11,"clone","","",9,[[["self"]],["cvtype"]]],[11,"clone","","",14,[[["self"]],["rotatedrect"]]],[11,"clone","","",10,[[["self"]],["normtype"]]],[11,"clone","","",11,[[["self"]],["termtype"]]],[11,"clone","cv::cuda","",59,[[["self"]],["cgpumat"]]],[11,"clone","","",60,[[["self"]],["cgpuhog"]]],[11,"clone","","",61,[[["self"]],["cgpucascade"]]],[11,"clone","cv::features2d","",20,[[["self"]],["kmeanscenters"]]],[11,"clone","","",62,[[["self"]],["dmatch"]]],[11,"clone","","",21,[[["self"]],["descriptormatchertype"]]],[11,"clone","","",25,[[["self"]],["mserbuilder"]]],[11,"clone","","",27,[[["self"]],["siftbuilder"]]],[11,"clone","","",29,[[["self"]],["surfbuilder"]]],[11,"clone","cv::highgui","",38,[[["self"]],["windowflag"]]],[11,"clone","","",39,[[["self"]],["mouseeventtype"]]],[11,"clone","cv::imgcodecs","",41,[[["self"]],["imagereadmode"]]],[11,"clone","","",42,[[["self"]],["imagewritemode"]]],[11,"clone","","",43,[[["self"]],["imagewritepngstrategy"]]],[11,"clone","cv::imgproc","",44,[[["self"]],["histogramcomparisionmethod"]]],[11,"clone","","",45,[[["self"]],["thresholdtype"]]],[11,"clone","","",46,[[["self"]],["colorconversion"]]],[11,"clone","","",47,[[["self"]],["interpolationflag"]]],[11,"clone","cv::mat","",63,[[["self"]],["cmat"]]],[11,"clone","","",49,[[["self"]],["bordertype"]]],[11,"clone","","",48,[[["self"]],["self"]]],[11,"clone","cv::objdetect","",64,[[["self"]],["csvmdetector"]]],[11,"clone","","",50,[[["self"]],["hogparams"]]],[11,"clone","cv::videoio","",55,[[["self"]],["capprop"]]],[11,"clone","","",56,[[["self"]],["videowriterproperty"]]],[11,"drop","cv::core","",15,[[["self"]]]],[11,"drop","cv::cuda","",16,[[["self"]]]],[11,"drop","","",17,[[["self"]]]],[11,"drop","","",18,[[["self"]]]],[11,"drop","cv::features2d","",22,[[["self"]]]],[11,"drop","","",23,[[["self"]]]],[11,"drop","","",24,[[["self"]]]],[11,"drop","","",26,[[["self"]]]],[11,"drop","","",28,[[["self"]]]],[11,"drop","cv::hash","",32,[[["self"]]]],[11,"drop","","",33,[[["self"]]]],[11,"drop","","",34,[[["self"]]]],[11,"drop","","",35,[[["self"]]]],[11,"drop","","",36,[[["self"]]]],[11,"drop","","",37,[[["self"]]]],[11,"drop","cv::mat","",48,[[["self"]]]],[11,"drop","cv::objdetect","",53,[[["self"]]]],[11,"drop","","",54,[[["self"]]]],[11,"drop","","",51,[[["self"]]]],[11,"drop","cv::videoio","",57,[[["self"]]]],[11,"drop","","",58,[[["self"]]]],[11,"fmt","cv::errors","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::core","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::cuda","",59,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::errors","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::features2d","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",62,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::hash","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::highgui","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::imgcodecs","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::imgproc","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::mat","",63,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::objdetect","",53,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","cv::videoio","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",56,[[["self"],["formatter"]],["result"]]],[11,"hash","cv::core","",7,N],[11,"hash","","",8,N],[11,"hash","","",9,N],[11,"hash","","",10,N],[11,"hash","","",11,N],[11,"hash","cv::highgui","",38,N],[11,"hash","","",39,N],[11,"hash","cv::imgcodecs","",41,N],[11,"hash","","",42,N],[11,"hash","","",43,N],[11,"hash","cv::imgproc","",44,N],[11,"hash","","",45,N],[11,"hash","","",46,N],[11,"hash","","",47,N],[11,"hash","cv::videoio","",55,N],[11,"hash","","",56,N],[11,"not","cv::mat","",48,N],[11,"bitand","","",48,N],[11,"bitor","","",48,N],[11,"bitxor","","",48,N],[11,"name","cv::errors","",19,[[["self"]],["option",["str"]]]],[11,"cause","","",19,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",19,[[["self"]],["option",["backtrace"]]]],[11,"image_decode","cv::mat","Decodes an image from `buf` according to the specified mode.",48,N],[11,"image_encode","","Encodes an image; the encoding scheme depends on the extension provided; additional write flags can be passed in using a vector. If successful, returns an owned vector of the encoded image.",48,[[["self"],["str"],["vec",["imagewritemode"]]],["result",["vec","error"]]]],[11,"from_path","","Creates a `Mat` from reading the image specified by the path.",48,[[["p"],["imagereadmode"]],["result",["mat","error"]]]],[11,"line","","Draws a simple line.",48,[[["self"],["point2i"],["point2i"]]]],[11,"line_custom","","Draws a line with custom color, thickness and linetype.",48,[[["self"],["point2i"],["point2i"],["scalar"],["c_int"],["linetype"],["c_int"]]]],[11,"rectangle","","Draws a simple, thick, or filled up-right rectangle.",48,[[["self"],["rect"]]]],[11,"rectangle_custom","","Draws a rectangle with custom color, thickness and linetype.",48,[[["self"],["rect"],["scalar"],["c_int"],["linetype"]]]],[11,"rectangle2f","","Draw a simple, thick, or filled up-right rectangle.",48,[[["self"],["rect2f"]]]],[11,"ellipse","","Draws a simple, thick ellipse",48,[[["self"],["point2i"],["size2i"],["f64"],["f64"],["f64"]]]],[11,"ellipse_custom","","Draws a custom ellipse",48,[[["self"],["point2i"],["size2i"],["f64"],["f64"],["f64"],["scalar"],["c_int"],["linetype"],["c_int"]]]],[11,"cvt_color","","Convert an image from one color space to another.",48,[[["self"],["colorconversion"]],["mat"]]],[11,"pyr_down","","Blurs an image and downsamples it. This function performs the downsampling step of the Gaussian pyramid construction.",48,[[["self"]],["mat"]]],[11,"threshold","","Threshold",48,[[["self"],["f64"],["f64"],["thresholdtype"]],["mat"]]],[11,"erode","","Erode",48,[[["self"],["mat"],["point2i"],["i32"],["bordertype"],["scalar"]],["mat"]]],[11,"dilate","","Dilate",48,[[["self"],["mat"],["point2i"],["i32"],["bordertype"],["scalar"]],["mat"]]],[11,"gaussian_blur","","Gaussian Blur",48,[[["self"],["size2i"],["f64"],["f64"],["bordertype"]],["mat"]]],[11,"resize_to","","Resizes an image.",48,[[["self"],["size2i"],["interpolationflag"]],["mat"]]],[11,"resize_by","","Resizes an image.",48,[[["self"],["f64"],["f64"],["interpolationflag"]],["mat"]]],[11,"calc_hist","","Calculate a histogram of an image.",48,[[["self"],["t"],["mat"],["u"],["m"]],["mat"]]],[11,"calc_back_project","","Calculate the back projection of a histogram. The function calculates the back project of the histogram.",48,[[["self"],["t"],["mat"],["m"]],["mat"]]],[11,"compare_hist","","Compares two histograms. The function compare two histograms using the specified method. The function returns d(first_image, second_image). While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms or more general sparse configurations of weighted points, consider using the cv::EMD function.",48,[[["self"],["mat"],["histogramcomparisionmethod"]],["result",["f64","string"]]]],[11,"canny","","Performs canny edge detection",48,[[["self"],["f64"],["f64"],["i32"],["bool"]],["result",["mat","string"]]]]],"paths":[[3,"KeyPoint"],[3,"Point2i"],[3,"Point2f"],[3,"Size2i"],[3,"Size2f"],[3,"Rect"],[3,"Rect2f"],[4,"LineType"],[4,"FlipCode"],[4,"CvType"],[4,"NormType"],[4,"TermType"],[8,"FromBytes"],[3,"Scalar"],[3,"RotatedRect"],[3,"TermCriteria"],[3,"GpuMat"],[3,"GpuHog"],[3,"GpuCascade"],[4,"CvError"],[4,"KMeansCenters"],[4,"DescriptorMatcherType"],[3,"BOWKMeansTrainer"],[3,"DescriptorMatcher"],[3,"MSER"],[3,"MSERBuilder"],[3,"SIFT"],[3,"SIFTBuilder"],[3,"SURF"],[3,"SURFBuilder"],[8,"Feature2D"],[8,"Hash"],[3,"AverageHash"],[3,"BlockMeanHash"],[3,"ColorMomentHash"],[3,"MarrHildrethHash"],[3,"PHash"],[3,"RadialVarianceHash"],[4,"WindowFlag"],[4,"MouseEventType"],[8,"Show"],[4,"ImageReadMode"],[4,"ImageWriteMode"],[4,"ImageWritePngStrategy"],[4,"HistogramComparisionMethod"],[4,"ThresholdType"],[4,"ColorConversion"],[4,"InterpolationFlag"],[3,"Mat"],[4,"BorderType"],[3,"HogParams"],[3,"HogDescriptor"],[8,"ObjectDetect"],[3,"CascadeClassifier"],[3,"SvmDetector"],[4,"CapProp"],[4,"VideoWriterProperty"],[3,"VideoCapture"],[3,"VideoWriter"],[4,"CGpuMat"],[4,"CGpuHog"],[4,"CGpuCascade"],[3,"DMatch"],[4,"CMat"],[4,"CSvmDetector"]]};
initSearch(searchIndex);
